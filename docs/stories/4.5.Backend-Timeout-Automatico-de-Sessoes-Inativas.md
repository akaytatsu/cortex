# Story 4.5: Backend - Timeout Automático de Sessões Inativas

**Status**: Done

## Story
**As a** Desenvolvedor(a),
**I want** que sessões inativas por mais de 12 horas sejam encerradas,
**so that** os recursos do sistema sejam preservados.

## Acceptance Criteria
1. Uma tarefa agendada verifica periodicamente o `sessions.yaml`.
2. Sessões com mais de 12 horas de duração são identificadas.
3. O processo `claude code` correspondente é encerrado, e a entrada é removida do `sessions.yaml`.

## Tasks / Subtasks
- [x] **Task 1: Criar SessionTimeoutService** (AC: 1, 2, 3)
  - [x] Subtask 1.1: Criar arquivo `apps/web/app/services/session-timeout.service.ts` [Source: architecture/source-tree.md#14]
  - [x] Subtask 1.2: Definir interface `ISessionTimeoutService` em `apps/web/app/types/services.ts` [Source: architecture/coding-standards.md#13]
  - [x] Subtask 1.3: Implementar método `checkAndCleanupTimedOutSessions(): Promise<void>`
  - [x] Subtask 1.4: Configurar timeout de 12 horas (12 * 60 * 60 * 1000 ms) como constante
  - [x] Subtask 1.5: Integrar com SessionPersistenceService para carregar sessões ativas
  - [x] Subtask 1.6: Verificar tempo de vida da sessão comparando startedAt com horário atual
  - [x] Subtask 1.7: Para sessões expiradas, encerrar processo usando process.kill(pid, 'SIGTERM')
  - [x] Subtask 1.8: Para processos que não respondem, usar SIGKILL após timeout de graceful shutdown
  - [x] Subtask 1.9: Remover sessões expiradas do sessions.yaml via SessionPersistenceService
  - [x] Subtask 1.10: Configurar logger estruturado usando `createServiceLogger` [Source: architecture/error-handling-strategy.md#6]
  - [x] Subtask 1.11: Implementar tratamento de erros para processos já encerrados ou PIDs inválidos

- [x] **Task 2: Implementar Agendamento Periódico de Limpeza** (AC: 1)
  - [x] Subtask 2.1: Criar método `startPeriodicCleanup(intervalMs?: number): NodeJS.Timeout`
  - [x] Subtask 2.2: Configurar intervalo padrão de verificação (30 minutos)
  - [x] Subtask 2.3: Implementar método `stopPeriodicCleanup()` para parar o agendamento
  - [x] Subtask 2.4: Adicionar logs informativos sobre início e parada do agendamento
  - [x] Subtask 2.5: Garantir que apenas uma instância do timer está ativa (singleton pattern)
  - [x] Subtask 2.6: Tratar erros durante execução periódica sem parar o agendamento

- [x] **Task 3: Integrar SessionTimeoutService com Aplicação Principal** (AC: 1, 2, 3)
  - [x] Subtask 3.1: Inicializar SessionTimeoutService no startup da aplicação (main server file)
  - [x] Subtask 3.2: Iniciar limpeza periódica no boot da aplicação
  - [x] Subtask 3.3: Configurar graceful shutdown para parar timers ao encerrar aplicação
  - [x] Subtask 3.4: Adicionar logs de inicialização e shutdown do serviço de timeout
  - [x] Subtask 3.5: Garantir que o serviço seja iniciado apenas após SessionPersistenceService estar disponível

- [x] **Task 4: Adicionar Testes Unitários** (AC: 1, 2, 3)
  - [x] Subtask 4.1: Criar arquivo `apps/web/app/services/session-timeout.service.test.ts` [Source: architecture/test-strategy.md#11]
  - [x] Subtask 4.2: Testar identificação de sessões expiradas (mais de 12 horas)
  - [x] Subtask 4.3: Testar que sessões recentes (menos de 12 horas) não são encerradas
  - [x] Subtask 4.4: Testar encerramento de processo com SIGTERM seguido de SIGKILL se necessário
  - [x] Subtask 4.5: Testar remoção de sessões expiradas do arquivo sessions.yaml
  - [x] Subtask 4.6: Testar comportamento com PIDs inválidos ou processos já encerrados
  - [x] Subtask 4.7: Testar agendamento periódico (start/stop de timers)
  - [x] Subtask 4.8: Mockar SessionPersistenceService e process.kill para isolar testes [Source: architecture/test-strategy.md#12]
  - [x] Subtask 4.9: Testar graceful shutdown do serviço
  - [x] Subtask 4.10: Testar tratamento de erros durante limpeza periódica

## Dev Notes

### Previous Story Insights
- **SessionPersistenceService** já implementado na história 4.4 com cache TTL e sistema de backup
- Sistema robusto de recuperação de sessões com verificação de processos ativos usando process.kill(pid, 0)
- Interface PersistedSession com campos: id, workspaceName, workspacePath, pid, startedAt, agentName, command, userId, recovered
- Logs estruturados e tratamento de erros já estabelecidos no padrão do projeto

### Data Models
- **Interface PersistedSession** já existe em `packages/shared-types/index.ts` com campo `startedAt: string` (ISO date string)
- **Timeout Configuration**:
  ```typescript
  const SESSION_TIMEOUT_MS = 12 * 60 * 60 * 1000; // 12 hours
  const CLEANUP_INTERVAL_MS = 30 * 60 * 1000; // 30 minutes check interval
  const GRACEFUL_SHUTDOWN_TIMEOUT_MS = 5000; // 5 seconds for SIGTERM before SIGKILL
  ```

### API Specifications
- Não há endpoints REST nesta história, apenas serviço interno de background

### Component Specifications
- Não há componentes UI nesta história

### File Locations
- **Novo serviço**: `apps/web/app/services/session-timeout.service.ts`
- **Interface do serviço**: Adicionar em `apps/web/app/types/services.ts`
- **Testes**: `apps/web/app/services/session-timeout.service.test.ts`
- **Integração**: Modificar arquivo principal de inicialização da aplicação

### Testing Requirements
- Framework: Vitest [Source: architecture/test-strategy.md#11]
- Cobertura mínima: 80% [Source: architecture/test-strategy.md#8]
- Mockar process.kill, setTimeout/clearTimeout e SessionPersistenceService [Source: architecture/test-strategy.md#12]
- Testar casos de erro e edge cases [Source: architecture/test-strategy.md#8]

### Technical Constraints
- Usar SessionPersistenceService existente para operações com sessions.yaml [Source: história 4.4]
- Seguir padrão de injeção de dependências [Source: architecture/coding-standards.md#13]
- Implementar ILogger para logs estruturados [Source: architecture/error-handling-strategy.md#6]
- Timeout de 12 horas conforme especificado no épico
- Intervalo de verificação de 30 minutos para balancear performance e responsividade
- Graceful shutdown com SIGTERM seguido de SIGKILL se necessário

### Security Considerations
- Validar PIDs antes de tentar encerrar processos
- Usar SIGTERM primeiro para permitir cleanup graceful do processo claude code
- Não logar informações sensíveis sobre usuários ou workspaces em logs de erro
- Verificar permissões antes de encerrar processos (apenas processos próprios)

### Integration Points
- **SessionPersistenceService**: Principal dependência para leitura/escrita de sessions.yaml
- **CliService**: Potencial integração futura para notificar sobre sessões encerradas
- **WebSocketManager**: Potencial integração para notificar clientes sobre sessões encerradas por timeout
- **Application Bootstrap**: Inicialização do serviço no startup da aplicação

### Performance Considerations
- Cache do SessionPersistenceService (5 min TTL) reduz I/O durante verificações periódicas
- Intervalo de 30 minutos balanceia responsividade vs overhead do sistema
- Graceful shutdown com timeout de 5 segundos evita processos zumbis
- Logs de debug apenas para desenvolvimento, logs info para produção

## Testing

### Test file location
- `apps/web/app/services/session-timeout.service.test.ts`

### Test standards
- Usar Vitest com describe/it blocks [Source: architecture/test-strategy.md#11]
- Mockar todas as dependências externas (SessionPersistenceService, process.kill, timers)
- Testar casos de sucesso e falha
- Verificar logs com mock de ILogger

### Testing frameworks and patterns to use
- Vitest para unit tests
- Mock de SessionPersistenceService para isolar lógica de timeout
- Mock de process.kill para simular encerramento de processos
- Mock de setTimeout/clearTimeout para testar agendamento
- Usar beforeEach/afterEach para setup/cleanup de timers
- Fixtures para dados de teste de sessões com diferentes idades

### Specific testing requirements for this story
- Testar cálculo correto de idade da sessão (startedAt vs Date.now())
- Testar que sessões com menos de 12 horas são mantidas
- Testar que sessões com mais de 12 horas são encerradas
- Testar sequência SIGTERM -> aguardar -> SIGKILL se necessário
- Testar comportamento com PIDs inválidos ou processos já mortos
- Testar que o timer periódico pode ser iniciado e parado corretamente
- Testar que erros durante limpeza não param o agendamento
- Verificar que sessions.yaml é atualizado após limpeza de sessões expiradas

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-23 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-07-23 | 1.1 | Implementation completed | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
- **Claude Sonnet 4** (claude-sonnet-4-20250514)

### Debug Log References
- All implementation details logged during development
- Test execution results documented
- Service integration verified

### Completion Notes
- ✅ **SessionTimeoutService criado** com todos os métodos necessários para timeout de 12 horas
- ✅ **Interface ISessionTimeoutService** definida em types/services.ts
- ✅ **Agendamento periódico** implementado com intervalo padrão de 30 minutos
- ✅ **Integração com aplicação** através do service-container e entry.server.tsx
- ✅ **Graceful shutdown** configurado para parar timers ao encerrar aplicação
- ✅ **Testes unitários** implementados com 11 testes passando, cobrindo cenários principais
- ✅ **Logs estruturados** implementados usando createServiceLogger
- ✅ **Tratamento de erros** para PIDs inválidos, processos inexistentes e erros de permissão

### File List
- **apps/web/app/services/session-timeout.service.ts** - Novo serviço principal
- **apps/web/app/services/session-timeout.service.test.ts** - Testes unitários
- **apps/web/app/types/services.ts** - Interface ISessionTimeoutService adicionada
- **apps/web/app/lib/service-container.ts** - Serviços registrados no container
- **apps/web/app/entry.server.tsx** - Inicialização e graceful shutdown configurados

**Status**: Ready for Review

## QA Results

**Reviewed by:** Quinn (Senior Developer & QA Architect) 🧪
**Review Date:** 2025-07-23
**Review Status:** ✅ **APROVADO**

### ✅ Code Quality Assessment

**SessionTimeoutService (apps/web/app/services/session-timeout.service.ts:184)**
- **Arquitetura**: Excelente implementação seguindo padrões SOLID e injeção de dependências
- **Configuração**: Constantes bem definidas (12h timeout, 30min intervalo, 5s graceful shutdown)
- **Tratamento de Processos**: Implementação robusta com SIGTERM → SIGKILL fallback
- **Error Handling**: Tratamento abrangente de PIDs inválidos (ESRCH) e permissões (EPERM)
- **Logging**: Logs estruturados com contexto adequado, sem vazamento de dados sensíveis
- **Performance**: Polling eficiente de 100ms para verificação de término de processos

**Interface Definition (apps/web/app/types/services.ts:112-116)**
- Interface clara e bem definida seguindo padrões do projeto
- Métodos apropriados para gerenciamento do ciclo de vida do serviço

**Service Integration (apps/web/app/lib/service-container.ts:69-72)**
- Integração adequada via service container com injeção de dependências
- Singleton pattern corretamente implementado

**Application Bootstrap (apps/web/app/entry.server.tsx:25-38)**
- Inicialização no startup da aplicação implementada corretamente
- Graceful shutdown configurado para SIGINT e SIGTERM
- Logs informativos sobre inicialização e parada do serviço

### ✅ Test Coverage & Quality

**Test Suite (apps/web/app/services/session-timeout.service.test.ts:302)**
- **Coverage**: 11 testes passando, cobrindo cenários principais ✅
- **Mocking Strategy**: Excelente uso de mocks para process.kill, timers e SessionPersistenceService
- **Edge Cases**: Testes abrangentes para PIDs inválidos, permissões, processos inexistentes
- **Error Scenarios**: Validação de comportamento durante falhas de cleanup periódico
- **Timer Management**: Verificação adequada de singleton pattern e lifecycle de timers

**Test Execution Results:**
```
✓ apps/web/app/services/session-timeout.service.test.ts (11 tests) 22ms
Test Files  1 passed (1)
Tests  11 passed (11)
```

### ✅ Architecture Compliance

**Coding Standards Adherence:**
- ✅ TypeScript 5.8 e Node.js 22.x
- ✅ Shared types importados de `packages/shared-types`
- ✅ Business logic em `apps/web/app/services/`
- ✅ Error handling com classes customizadas
- ✅ Naming conventions seguidas (camelCase para services)
- ✅ Interface segregation seguindo padrões do projeto

**Error Handling Strategy:**
- ✅ Logs estruturados usando Pino/logger estruturado
- ✅ Sem exposição de dados sensíveis em logs
- ✅ Tratamento apropriado de exceções com continuidade do serviço

### ✅ Acceptance Criteria Validation

**AC 1 - Tarefa Agendada Periódica:**
- ✅ `startPeriodicCleanup()` implementado com intervalo de 30 minutos
- ✅ Singleton pattern garante apenas uma instância ativa
- ✅ Timer configurável via parâmetro opcional

**AC 2 - Identificação de Sessões Expiradas:**
- ✅ Lógica de timeout de 12 horas implementada corretamente
- ✅ Comparação precisa entre `startedAt` e timestamp atual
- ✅ Logs informativos sobre sessões identificadas para limpeza

**AC 3 - Encerramento e Remoção:**
- ✅ Processo `claude code` encerrado com `process.kill(pid, 'SIGTERM')`
- ✅ Fallback para `SIGKILL` após timeout de 5 segundos
- ✅ Remoção da entrada via `SessionPersistenceService.removeSession()`
- ✅ Tratamento robusto de processos já encerrados ou com PIDs inválidos

### 🔧 Minor Improvements Applied

Durante a revisão, identifiquei que o código está muito bem implementado e não requer refatorações significativas. A implementação segue fielmente as especificações e padrões arquiteturais estabelecidos.

### 📋 Security & Performance Validation

**Security:**
- ✅ Validação de PIDs antes de terminar processos
- ✅ Uso de SIGTERM para graceful shutdown
- ✅ Logs não expõem informações sensíveis
- ✅ Tratamento adequado de erros de permissão

**Performance:**
- ✅ Cache do SessionPersistenceService reduz I/O
- ✅ Intervalo de 30 minutos balanceia responsividade vs overhead
- ✅ Timeout de graceful shutdown evita processos zumbis
- ✅ Polling eficiente de 100ms para verificação de processos

### ✅ Final Recommendation

**STORY APROVADA PARA PRODUÇÃO**

A implementação do SessionTimeoutService está tecnicamente sólida, segue rigorosamente os padrões arquiteturais estabelecidos, possui cobertura de testes adequada e atende completamente aos critérios de aceitação. O código demonstra maturidade técnica e pode ser deployado com confiança.

**Ready for Deployment** ✅