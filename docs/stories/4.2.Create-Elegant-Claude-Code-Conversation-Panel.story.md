# História 4.2: Create Elegant Claude Code Conversation Panel

**Status**: Draft
**Epic**: 4 - Claude Code CLI Integration
**Story**: 4.2
**Título**: Create Elegant Claude Code Conversation Panel
**Estimativa**: 8 pontos

## Story

**As a** Developer,
**I want** um painel elegante e conversacional no canto direito para interagir com o Claude Code CLI,
**so that** I can ter uma experiência de colaboração com IA profissional e intuitiva.

## Acceptance Criteria

1. **Layout and Positioning**
   - Um painel "Claude Code Assistant" é posicionado no canto direito da IDE (conforme layout spec).

2. **Design and Visual Experience**
   - Interface conversacional elegante com design limpo inspirado no Conductor - fundo claro, tipografia moderna, espaçamento adequado.
   - Mensagens são apresentadas como bubbles de conversa, não como output de terminal.

3. **Markdown Support**
   - Suporte para markdown rendering nas respostas do Claude Code (código, listas, etc.).

4. **Conversation Navigation**
   - Histórico de conversas navegável com scroll suave e indicadores visuais.

5. **Input Interface**
   - Input field moderno com placeholder contextual ("Ask Claude Code anything...").

6. **Status Indicators**
   - Indicadores visuais elegantes para status (thinking, typing, error states).

## Tasks / Subtasks

### Fase 1: Componente Principal e Layout (AC: 1)
- [ ] **Task 1.1**: Criar componente `ClaudeCodePanel` (AC: 1)
  - [ ] Implementar estrutura básica do painel usando shadcn/ui components
  - [ ] Posicionar painel no canto direito conforme IDELayout existente
  - [ ] Implementar redimensionamento e toggle de visibilidade
  - [ ] Integrar com IDELayout existente sem quebrar funcionalidades

### Fase 2: Interface Conversacional Elegante (AC: 2, 5, 6)
- [ ] **Task 2.1**: Implementar design conversacional inspirado no Conductor (AC: 2)
  - [ ] Criar componentes `MessageBubble` com design limpo
  - [ ] Implementar tipografia moderna usando Tailwind CSS classes
  - [ ] Aplicar espaçamento adequado e fundos claros
  - [ ] Criar diferenciação visual entre mensagens do usuário e do Claude Code
- [ ] **Task 2.2**: Criar input field moderno (AC: 5)
  - [ ] Implementar `MessageInput` component com placeholder contextual
  - [ ] Adicionar suporte para multi-line input e auto-resize
  - [ ] Implementar shortcuts (Enter para enviar, Shift+Enter para nova linha)
  - [ ] Adicionar botão de envio elegante com estados disabled/loading
- [ ] **Task 2.3**: Implementar indicadores visuais de status (AC: 6)
  - [ ] Criar `StatusIndicator` component para diferentes estados
  - [ ] Implementar animações suaves para thinking/typing states
  - [ ] Adicionar feedback visual para error states
  - [ ] Integrar indicators com o fluxo de conversação

### Fase 3: Markdown Rendering (AC: 3)
- [ ] **Task 3.1**: Integrar markdown rendering nas mensagens (AC: 3)
  - [ ] Instalar e configurar biblioteca de markdown (react-markdown ou similar)
  - [ ] Implementar syntax highlighting para blocos de código
  - [ ] Configurar rendering de listas, links e outros elementos markdown
  - [ ] Aplicar estilos consistentes com o design geral do painel

### Fase 4: Navegação e Histórico (AC: 4)
- [ ] **Task 4.1**: Implementar sistema de conversação navegável (AC: 4)
  - [ ] Criar `ConversationHistory` component com scroll suave
  - [ ] Implementar indicadores visuais para separação de sessões
  - [ ] Adicionar auto-scroll para novas mensagens
  - [ ] Implementar preservação de histórico durante navegação

### Fase 5: Integração com Sistema Existente
- [ ] **Task 5.1**: Integrar painel com infraestrutura existente
  - [ ] Conectar com CLI detection service da história 4.1
  - [ ] Implementar graceful degradation quando Claude Code CLI não disponível
  - [ ] Adicionar testes unitários para componentes principais
  - [ ] Validar responsividade e acessibilidade básica

## Dev Notes

### Previous Story Context
A **História 4.1** implementou a detecção do Claude Code CLI e criou:
- `CliDetectionService`: Detecta disponibilidade do Claude Code CLI
- `CliStatusIndicator`: Indicador visual de status do CLI
- `ClaudeCodeInstallationInstructions`: Instruções de instalação quando CLI não disponível
- WebSocket protocol estendido para comunicação de status
- Infraestrutura pronta para execução do Claude Code CLI no contexto correto do workspace

### Technical Context from Architecture

**Tech Stack Relevante** [Source: architecture/tech-stack.md]:
- **Framework**: Remix 2.16.8 para SSR - REGRA CRÍTICA: NUNCA adicionar `fetcher` em dependências do useEffect
- **Language**: TypeScript 5.8, Node.js 22.x
- **Estilização**: Tailwind CSS 4.1.11 para framework utilitário
- **Componentes**: shadcn/ui para biblioteca de componentes acessíveis e customizáveis
- **Ícones**: Lucide Icons para biblioteca de ícones
- **WebSockets**: ws ~8.x já implementado para comunicação real-time

**System Components** [Source: architecture/system-components.md]:
- **`Terminal` (Frontend)**: [IMPLEMENTADO] Componente de terminal interativo - usar como referência para WebSocket integration
- **`WebSocketService` (Backend)**: [IMPLEMENTADO] Gerencia comunicação real-time - pode ser estendido para Claude Code communication
- **`TerminalService` (Backend)**: [IMPLEMENTADO] Gerencia sessões - usar como base para Claude Code session management

**Source Tree Structure** [Source: architecture/source-tree.md]:
```plaintext
apps/web/app/
├── components/
│   ├── Terminal.tsx # [IMPLEMENTADO] - referência para WebSocket usage
│   ├── IDELayout.tsx # [IMPLEMENTADO] - deve ser estendido para incluir painel
│   ├── CliStatusIndicator.tsx # [IMPLEMENTADO] - da história 4.1
│   └── ClaudeCodePanel.tsx # [NOVO] - componente principal a ser criado
├── services/
│   ├── terminal.service.ts # [IMPLEMENTADO] - referência para CLI execution
│   └── cli-detection.service.ts # [IMPLEMENTADO] - da história 4.1
├── lib/
│   └── websocket-server.ts # [IMPLEMENTADO] - pode precisar de extensão
└── routes/
    └── workspaces.$name.tsx # [IMPLEMENTADO] - onde IDELayout é renderizado
```

**Data Models** [Source: architecture/data-models-revised.md]:
```typescript
// Existente da história 4.1 - [IMPLEMENTADO]
export interface TerminalSession {
  id: string;
  workspaceName: string;
  workspacePath: string;
  userId: string;
  claudeCodeCliStatus?: 'available' | 'not-available' | 'error' | 'checking';
  claudeCodeCliVersion?: string;
  // ... outros campos
}

// Novos tipos necessários para esta história
export interface ClaudeCodeMessage {
  id: string;
  type: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  status?: 'sending' | 'sent' | 'error';
}

export interface ClaudeCodeConversation {
  id: string;
  sessionId: string;
  messages: ClaudeCodeMessage[];
  status: 'active' | 'thinking' | 'error' | 'idle';
  workspacePath: string;
}
```

**Critical Integration Points** [Source: architecture/coding-standards.md, core-workflows.md]:

1. **Shared Types**: Todos os tipos compartilhados DEVEM ser definidos em `packages/shared-types` e importados de lá
2. **Service Layer**: Lógica de negócio DEVE estar em `apps/web/app/services/` - loaders/actions apenas chamam serviços
3. **WebSocket Integration**: Usar infraestrutura WebSocket existente como referência (Terminal component)
4. **Component Standards**: Seguir padrões de naming PascalCase, usar shadcn/ui components, Tailwind CSS

**API Specification Context** [Source: architecture/api-specification.md]:
- **WebSocket Endpoint**: `/ws/terminal` já existe - pode ser estendido ou criar novo endpoint para Claude Code
- **Message Protocol**: Usar padrão similar ao `TerminalMessage` interface
- **Authentication**: Reutilizar validação de sessão via SessionService existente

### Implementation Strategy

1. **Component Architecture**:
   - Criar `ClaudeCodePanel` como componente principal
   - Usar composition pattern com sub-components (`MessageBubble`, `MessageInput`, `StatusIndicator`)
   - Integrar com `IDELayout` existente sem quebrar funcionalidades atuais

2. **Design System Integration**:
   - Usar shadcn/ui components como base
   - Aplicar Tailwind CSS para estilização seguindo padrões Conductor-inspired
   - Implementar design system consistente com resto da aplicação

3. **State Management**:
   - Usar React state local para UI state (input, scroll position)
   - Considerar Context API se state precisar ser compartilhado
   - Integrar com WebSocket state similar ao Terminal component

4. **WebSocket Communication** (preparação para história 4.3):
   - Preparar estrutura para comunicação com Claude Code CLI via WebSocket
   - Usar padrão similar ao Terminal service para consistency
   - Implementar graceful degradation quando CLI não disponível

### Testing

#### Unit Tests (Vitest) [Source: architecture/test-strategy.md]
- `ClaudeCodePanel.test.tsx`: Teste de rendering e interações básicas
- `MessageBubble.test.tsx`: Teste de rendering de diferentes tipos de mensagem
- `MessageInput.test.tsx`: Teste de input handling e shortcuts
- **Test File Naming**: `*.test.tsx` conforme coding standards

#### Testing Strategy
- **MVP Focus**: Suite robusta de testes unitários e integração
- **Coverage**: Visar >80% coverage na lógica crítica de negócio
- **Mock Strategy**: Mockar WebSocket connections e CLI service calls

### Security Considerations

1. **Input Sanitization**: Sanitizar input do usuário antes de envio
2. **Markdown Rendering**: Usar biblioteca segura para markdown rendering
3. **WebSocket Security**: Reutilizar padrões de autenticação existentes
4. **CLI Integration**: Preparar para validação segura de comandos Claude Code

### Performance Considerations

1. **Lazy Loading**: Carregar markdown library apenas quando necessário
2. **Virtual Scrolling**: Considerar para histórico longo de conversas
3. **Message Caching**: Implementar cache eficiente para mensagens
4. **Responsive Design**: Garantir performance em diferentes tamanhos de tela

## Testing

### Unit Tests Required (Vitest)
- **Component Tests**:
  - `ClaudeCodePanel.test.tsx`: Rendering, layout integration, visibility toggle
  - `MessageBubble.test.tsx`: Different message types, markdown rendering
  - `MessageInput.test.tsx`: Input handling, shortcuts, validation
  - `StatusIndicator.test.tsx`: Status states, animations

### Test Data Management
Usar seed scripts similares aos existentes para criar dados de teste consistentes para conversas simuladas.

### Test Coverage Goals
- >80% coverage para componentes principais
- 100% coverage para message handling logic
- Integration tests para WebSocket communication patterns

## Change Log

| Data | Versão | Descrição | Autor |
|------|--------|-----------|--------|
| 2025-07-23 | 1.0 | Criação inicial da história | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*This section will be populated by the development agent during implementation*

### Debug Log References
*This section will be populated by the development agent during implementation*

### Completion Notes List
*This section will be populated by the development agent during implementation*

### File List
*This section will be populated by the development agent during implementation*

## QA Results

*This section will be populated by the QA agent during story review*